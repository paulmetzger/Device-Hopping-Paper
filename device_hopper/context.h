//
// Created by paul on 09/10/2019.
//

#ifndef LIBRARY_PLASTICITY_H
#define LIBRARY_PLASTICITY_H

#include <stdlib.h>
#include <boost/program_options.hpp>
#include <semaphore.h>
#include <fcntl.h>
#include <fstream>
#include <iostream>
#include <sys/stat.h>

#include "internal/app_type.h"
#include "../device_hopper/internal/device.h"
#include "../device_hopper/internal/scheduler.h"
#include "../device_hopper/internal/utils.h"

namespace boost_po  = boost::program_options;

namespace plasticity { namespace setup {
    class Context {
    public:
        Context(int argc, char* argv[], boost_po::options_description desc) : _desc(desc) {

            /*posix_memalign((void **) &this->sched, 64, sizeof(internal::Scheduler));
            this->sched = new(this->sched) internal::Scheduler;*/

            desc.add_options()
                ("help",                                                     "Show help message")
                ("back-to-back-scheduling-order", boost_po::value<int>(),    "The order in which kernels are executed in the back-to-back scheduling mode. Starts at 0.")
                ("benchmark-applications",  boost_po::value<int>(),          "Number of benchmark applications")
#if defined(SLICED_DATA_TRANSFERS)
                ("data-transf-slice-size-mb",  boost_po::value<int>(),          "Chunks in which data is transferred. Data transfers can be killed between slices.")
#endif
                ("cpu-x-slice-size",        boost_po::value<int>(),          "Slice size in x direction")
                ("gpu-x-slice-size",        boost_po::value<int>(),          "Slice size in x direction")
                ("cpu-y-slice-size",        boost_po::value<int>(),          "Slice size in y direction")
                ("gpu-y-slice-size",        boost_po::value<int>(),          "Slice size in y direction")

                ("launch-device",           boost_po::value<std::string>(),  "Device on which this application should be launched")
                ("no-kernel-migration",                                      "Kernels cannot be migrated while they are running (DEFAULT: OFF)")
                ("path-to-library",         boost_po::value<std::string>(),  "Path to the root directory of the plasticity library")
                ("preferred-device",        boost_po::value<std::string>(),  "The preferred device for this kernel. Options: CPU, GPU")
#if !defined(PLASTIC) || defined(ORACLE_WITH_DAEMON)
                ("scheduling-mode",         boost_po::value<std::string>(),  "Options: HTrOP, Back-to-Back, Back-to-Back-via-OpenCL, Best-Available "
                                                                             "HTrOP mode uses OpenCL kernels generated by HTrOP, "
                                                                             "uses OpenCL for all devices, and uses HTrOP scheduling "
                                                                             "heuristic (DEFAULT: First-Available)")
#endif
                ("slicing-mode",            boost_po::value<std::string>(),  "Options: SlicingOnAllDevices, NoSlicingOnPreferredDevice, NoSlicing, SlicingOnTheGPU "
                                                                             "(DEFAULT: SlicingOnAllDevices")
                ("sync-applications",                                        "Synchronise all benchmark applications at their start (DEFAULT: OFF)")

                ("tuning-mode",                                              "Use this mode to find the best tuning parameters for a kernel (DEFAULT: OFF)")
                ("tuning-device",           boost_po::value<std::string>(),  "Pin computation to a device for tuning purposes")
                ("tuning-cpu-core-count",   boost_po::value<int>(),          "The number of CPU cores computations on the CPU should use (DEFAULT: MAX)")
#if defined(DEBUG)
                ("debug-transfer-after-n-slices",  boost_po::value<int>(), "Debugging - Transfer to preferred device after n slices.")
#endif
                ;

            boost_po::store(boost_po::parse_command_line(argc, argv, desc), this->_vm);
            boost_po::notify(this->_vm);

            if (_vm.count("help")) {
                std::cout << desc << std::endl;
                std::exit(EXIT_SUCCESS);
            }

#if defined(DEBUG)
            if (_vm.count("debug-transfer-after-n-slices") == 1)
                this->sched.set_slices_before_migration(_vm["debug-transfer-after-n-slices"].as<int>());
#endif

            if (_vm.count("preferred-device") == 0) {
                std::cerr << "Error: Preferred device not set." << std::endl;
                std::exit(EXIT_FAILURE);
            } else {
                std::string device = _vm["preferred-device"].as<std::string>();
                Device preferred_device = Device::None;
                if (device == "GPU") {
                    preferred_device = Device::GPU;
                } else if (device == "CPU") {
                    preferred_device = Device::CPU;
                } else {
                    std::cerr << "Error: Unknown device" << std::endl;
                    std::exit(EXIT_FAILURE);
                }
                sched.set_preferred_device(preferred_device);
            }

            // Override scheduler decisions and settings in the config file
            if (_vm.count("tuning-mode")) {

                // Pin the computation to a device
                if (_vm.count("tuning-device") == 1) {
                    std::string device = _vm["tuning-device"].as<std::string>();
                    if (device == "CPU") {
                        this->sched.pin_computation_to_device(Device::CPU);
                    } else if (device == "GPU") {
                        this->sched.pin_computation_to_device(Device::GPU);
                    } else {
                        std::cerr << "Error: Unknown device" << std::endl;
                        std::cout << desc << std::endl;
                        std::exit(EXIT_FAILURE);
                    }
                }

                if (_vm.count("tuning-cpu-core-count")) {
                    this->control_cpu_core_count = true;
                    this->cpu_core_count = _vm["tuning-cpu-core-count"].as<int>();
                }
            }

            // Set the maximum slice sizes
            if (_vm.count("cpu-x-slice-size")  == 0 && _vm.count("cpu-y-slice-size") == 0) {
                if (_vm["slicing-mode"].as<std::string>() != "NoSlicing")
                    utils::exit_with_err("Error: CPU slice sizes are required but not set");
            } else {
                this->sched.set_cpu_slice_sizes(_vm["cpu-x-slice-size"].as<int>(),
                                                    _vm["cpu-y-slice-size"].as<int>());
            }

            if (_vm.count("gpu-x-slice-size") && _vm.count("gpu-y-slice-size")) {
                this->sched.set_gpu_slice_sizes(_vm["gpu-x-slice-size"].as<int>(),
                                                    _vm["gpu-y-slice-size"].as<int>());
            }

#if !defined(PLASTIC) || defined(ORACLE_WITH_DAEMON)
            if (_vm.count("scheduling-mode") == 1) {
                if (_vm["scheduling-mode"].as<std::string>() == "Best-Available") {
                    this->sched.set_scheduling_mode(SchedulingMode::BestAvailable);
                } else if(_vm["scheduling-mode"].as<std::string>() == "HTrOP") {
                    this->sched.set_scheduling_mode(SchedulingMode::HTrOP);
                } else if(_vm["scheduling-mode"].as<std::string>() == "Back-to-Back") {
                    if (_vm.count("back-to-back-scheduling-order") == 0) {
                        std::cerr << "Error: Back to back scheduling mode is selected but no order is provided" << std::endl;
                    }
                    if (_vm.count("benchmark-applications") == 0) {
                        std::cerr << "Error: Back to back scheduling mode is selected but the number of benchmark applications" << std::endl;
                    }
                    int scheduling_order  = _vm["back-to-back-scheduling-order"].as<int>();
                    int application_count = _vm["benchmark-applications"].as<int>();
                    this->sched.set_scheduling_mode(SchedulingMode::BacktoBack, scheduling_order, application_count);
                } else if(_vm["scheduling-mode"].as<std::string>() == "Back-to-Back-via-OpenCL") {
                    this->sched.set_scheduling_mode(SchedulingMode::BacktoBackViaOpenCL);
                } else if(_vm["scheduling-mode"].as<std::string>() == "Plastic") {
                    utils::exit_with_err(
                            "Error: This binary is for 'oracle experiments' and does not support plastic scheduling");
                } else {
                    std::cerr << "Error: Unknown scheduling mode" << std::endl;
                    std::exit(EXIT_FAILURE);
                }
            }

#elif defined(PLASTIC)
            this->sched.set_scheduling_mode(SchedulingMode::Plastic);
#endif

            if (_vm.count("slicing-mode") == 1) {
                if (_vm["slicing-mode"].as<std::string>() == "SlicingOnAllDevices") {
                    this->sched.set_slicing_mode(SlicingMode::SlicingOnAllDevices);
                } else if (_vm["slicing-mode"].as<std::string>() == "NoSlicingOnPreferredDevice") {
                    this->sched.set_slicing_mode(SlicingMode::NoSlicingOnPreferredDevice);
                } else if(_vm["slicing-mode"].as<std::string>() == "SlicingOnTheGPU") {
                    this->sched.set_slicing_mode(SlicingMode::SlicingOnTheGPU);
                } else if(_vm["slicing-mode"].as<std::string>() == "NoSlicing") {
                    this->sched.set_slicing_mode(SlicingMode::NoSlicing);
                } else {
                    utils::exit_with_err("Unknown slicing mode");
                }
            }

            this->sync_applications = _vm.count("sync-applications");
            if (_vm.count("benchmark-applications")) {
                this->bench_app_count = _vm["benchmark-applications"].as<int>();
            }

#if defined(SLICED_DATA_TRANSFERS)
            if (_vm.count("data-transf-slice-size-mb"))
                this->data_transf_slice_size_mb = _vm["data-transf-slice-size-mb"].as<int>();
            else
                utils::exit_with_err("Data transfer slice size is not set");
#endif


            if (_vm.count("launch-device")) {
                std::string device = _vm["launch-device"].as<std::string>();
                if (device == "CPU") {
                    this->sched.set_launch_device(Device::CPU);
                } else if (device == "GPU") {
                    this->sched.set_launch_device(Device::GPU);
                } else {
                    std::cerr << "Error: Unknown device" << std::endl;
                    std::cout << desc << std::endl;
                    std::exit(EXIT_FAILURE);
                }
            }

            if (_vm.count("execution-mode") == 1) {
                std::cout << "Warning: HTrOP emulation is not implemented yet" << std::endl;
            }

            if (_vm.count("path-to-library")) {
               this->library_path = _vm["path-to-library"].as<std::string>();
            } else {
                std::cerr << "Error: Path to the library is not set" << std::endl;
                std::cout << desc << std::endl;
                std::exit(EXIT_FAILURE);
            }

            if (_vm.count("create-barrier-ipc-shm")) this->create_barrier_shm = true;
        }

        void print_cli_help() {
            std::cout << _desc << std::endl;
        }

        boost_po::variables_map get_variables_map() {
            return this->_vm;
        }

        void wait_for_other_benchmark_applications(AppType app_type) {

            if (this->sync_applications) {
                sem_t* barrier_device_hog = sem_open("barrier_device_hog", O_CREAT, 0666, 0);
                sem_t* barrier_benchm     = sem_open("barrier_benchm",     O_CREAT, 0666, 0);
                if (app_type == AppType::BENCHM) {
                    sem_post(barrier_benchm);
                    sem_wait(barrier_device_hog);
                } else if (app_type == AppType::DEVICE_HOG) {
                    sem_post(barrier_device_hog);
                    sem_wait(barrier_benchm);
                } else {
                    utils::exit_with_err("Unknown application type");
                }
                sem_close(barrier_device_hog);
                sem_close(barrier_benchm);
/*                internal::ipc::Barrier barrier(
                        "plasticity_barrier",
                        this->create_barrier_shm,
                        this->bench_app_count);
                barrier.wait();*/
                usleep(100 * 1000);
            }
        }

        internal::Scheduler sched;


        //internal::Scheduler sched;
        long cpu_core_count  =  0;
        std::string library_path;
        int bench_app_count  = -1;
        int data_transf_slice_size_mb = -1;

        bool create_barrier_shm               = false;
        bool control_cpu_core_count           = false;
        bool ocl_runtime_chooses_the_wg_sizes = false;
        bool sync_applications                = false;

    private:
        boost_po::variables_map _vm;
        boost_po::options_description _desc;
    };
} }

#endif //LIBRARY_PLASTICITY_H
